# playground_cipher

## by *kaipan*

### Challenge Premise

Bruh I literally hate crypto because it makes my brain hurt but I also want the points, so here comes the pain... So the crypto black magic we dealing with today is based off of a cipher called Sarah2. Which is a pen and paper cipher, meaning that you could do the encrypting and decrypting manually with pen and paper pretty easily. This cipher has two stages that are repeated for a certain number of cycles or rounds to produce the final ciphertext. The cipher groups the plaintext into pairs of letters (padded to even length with _ if necessary) and then uses a random substitution box to substitute/permutate each pair of letters into a different pair of letters. Then the characters are shuffled by taking all characters in the odd positions (first character, third character, etc.) and grouping them all together in the same relative order in front of the grouping of all the even position characters (ex. 123456 -> 135246). This substitution and shuffle is repeated however many times you want. Undoing is relatively simple too, just inverse the steps (character pairs passed in substitution box in reverse and then shuffled the other way back).

### What's Different About The Playground Cipher?

Honestly since this was a two-week challenge, I forgot the exact specifics of the cipher, but it handles substitution differently by first shuffling the alphabet randomly (plus underscore) and then we take the indices of the *non-shuffled* alphabet for the substitution. For each character except for the first one, its substitution is the index value of the previous char and the index of itself combined and modulo'ed if necessary to wrap around. Then I think every character gets assigned to one of three groups in ascending order before repeating (123123123...) or something like that I don't remember, and then all members of group 3 go in the front, 1 in the middle and 2 at the end or in whatever order it was.

### How To Breakie the Cipher

The key insight is that this cipher, at its core, is the same round operation applied a whole bunch of times (substitution + permutation over and over). We can perform what is called a slide attack. We basically need to find a two plaintext and ciphertext pairs so to speak. We want to find the pairs in such a way that one encryption round on the first plaintext produces the second "plaintext" (which is kinda a ciphertext but for it to make sense we call it plaintext). We also want it such that when we apply all the rounds we want (the full encryption) we get the ciphertext, and then we can see that applying one round one the ciphertext of the first pair would produce the ciphertext of the second pair.

If we look at it more closely, we remember that since the cipher is just the same operation applied over and over again, by having the first plaintext go through a single round of encryption to produce the second plaintext, if we were to go through all encryption rounds we can see that the results for the second plaintext and eventual ciphertext is really just an offset so to speak of the first plaintext/ciphertext pair. The second plaintext is equivalent to applying one round of encryption on the first plaintext, and if the rounds do the same thing over and over again with the same substitution box, we can see that all the results between the encryptions of the first plaintext/ciphertext pair and the second are for the most part the same. The second plaintext starts encrypting at the place where the first plaintext is encrypted once, and the subsequent rounds should produce the same results and encrypting the same results should once again produce the same results between both pairs. But since the second plaintext is offset by one (ahead), it produces a final ciphertext one round forward relative to the first ciphertext. We are just "sliding" along the results of the encryption rounds, hence exploiting this is known as a sliding attack.

By having this relationship, we can essentially make guesses on what is substituted because we have the first plaintext which when encrypted by one round produces the second plaintext; We just see and make guesses on what the substitutions could be based on what we know about this cipher and how it gets transformed from first plaintext to second plaintext. Then since the final ciphertexts are also shifted by one, we can also use those to find and make more guesses about the substitution box based on how the first ciphertext is transformed into the second ciphertext in one encryption round. We just repeat this process of sliding forward by one encryption round and finding the possible substitutions until we know all substitutions to decipher the ciphertext (we are given decryption code but still need to figure out substitutions). The hard part is of course actually finding the plaintext/ciphertext pairs that adhere to these properties.

### I Don't Really Understand This Part And You Probably Won't Either

So based on how the substitution for this custom cipher works, we realize that the letter **a** has an index of 0 for substitution, meaning that we can have any letter and when combined with **a** for substitution we end up getting that same letter index again when substituting. So if we have a plaintext that is of the format **x**a**x** where x can be any letter we see that the resulting substitution is just whatever the substitution of x is, then the substitution of index of x + index of a, and then lastly the substitution of index of a + index of x. But since the index of a is 0, we end up getting substitution of whatever letter x is for all three characters. Now we can see that we can produce all sorts of ciphertext with one round of encryption where it follows the format **xxx** (x is again any letter) from the **x**a**x** format. Thus we can use **x**a**x** as the first plaintext, and **xxx**, which we get from one round of encryption on **x**a**x**, as the second plaintext, then whatever the full rounds of encryption are for **x**a**x** and **xxx** become the first and second ciphertexts for the respective pair.

Now we use both plaintexts and ciphertexts to perform trial and error to start figuring out the mappings for the substitutions as described above (figure mapping for first plaintext to second plaintext for one round and mappings for the first ciphertext to second ciphertext for one round) and then keep sliding forward in encryptions to figure out mappings until you get all substitutions or a contradiction indicating that your guess was wrong (you get another mapping for a previously mapped character). If it's the latter, then you gotta start over or maybe at the last guess that ended up being correct or something I don't know bro I haven't thought that far ahead yet. Basically we need to create a script to find all the substitutions and then use given decryption functions to decrypt and get flag.

### Script

LMAO SIKE I'M TOO LAZY TO WRITE A SCRIPT AND SO WAS MY TEAM SO YOU SHOULD'VE BEEN AT THE MEETING WHEN WE WENT OVER THIS ¯\_(ツ)_/¯ (or just do it by hand like a true gamer, it is a pen and paper cipher after all ;)). If you were at the meeting the flag was leaked anyway so none of this matters LMAO.

### Flag

`osu{if_rounds_are_the_same_just_be_a_leet_hacker_and_slide_around_them}`